-- Salt v5 — меню (исправления): корректные Drawing-ESP, bind для аима (по-умолчанию RMB), скролл-меню, плавные частицы
-- Запуск: LocalScript в StarterPlayerScripts / PlayerScripts. Тестировать в Studio (Play Solo).

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

-- Настройки
local Settings = {
    Fly = false,
    FlySpeed = 50,
    Noclip = false,
    WalkSpeed = 16,
    InfiniteJump = false,
    ESP = false,
    Aimbot = false,
    AimbotFOV = 120,     -- градусы
    AimbotSmooth = 0.15, -- 0..1
    TeamCheck = true,
    AimbotHoldMode = true -- если true — удержание бинда; если false — toggle
}

-- Drawing-хранение
local drawings = { boxes = {}, names = {}, fov = nil }
local espConnection, aimbotConnection, noclipConnection = nil, nil, nil
local flyBodyVelocity = nil
local aimBind = { InputType = Enum.UserInputType.MouseButton2, KeyCode = nil } -- по-умолчанию RMB
local bindingMode = false

-- HUD (PlayerGui) + DisplayOrder + З-индекс
local playerGui = player:WaitForChild("PlayerGui")
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "SaltV5_UI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 9999
screenGui.Parent = playerGui

-- Main короткий фрейм + ScrollingFrame для опций
local mainFrame = Instance.new("Frame")
mainFrame.Name = "Main"
mainFrame.Size = UDim2.new(0, 300, 0, 80) -- компактный, остальное через Scroll
mainFrame.Position = UDim2.new(0, 16, 0, 16)
mainFrame.BackgroundColor3 = Color3.fromRGB(20,20,20)
mainFrame.BorderSizePixel = 0
mainFrame.ZIndex = 50
mainFrame.Parent = screenGui
local mainCorner = Instance.new("UICorner", mainFrame); mainCorner.CornerRadius = UDim.new(0,10)

-- Title bar (перетаскивание)
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 32)
title.BackgroundTransparency = 1
title.Text = "Salt v5"
title.TextColor3 = Color3.fromRGB(230,230,230)
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.ZIndex = 51
title.Parent = mainFrame

-- Expand button
local expandBtn = Instance.new("TextButton")
expandBtn.Size = UDim2.new(0, 28, 0, 28)
expandBtn.Position = UDim2.new(1, -34, 0, 4)
expandBtn.Text = "+"
expandBtn.Font = Enum.Font.SourceSansBold
expandBtn.TextSize = 18
expandBtn.BackgroundColor3 = Color3.fromRGB(45,45,45)
expandBtn.TextColor3 = Color3.fromRGB(220,220,220)
expandBtn.ZIndex = 51
expandBtn.Parent = mainFrame
Instance.new("UICorner", expandBtn).CornerRadius = UDim.new(0,6)

-- Scrolling content (изначально скрыт)
local scroller = Instance.new("ScrollingFrame")
scroller.Name = "Content"
scroller.Size = UDim2.new(1, -12, 0, 360)
scroller.Position = UDim2.new(0, 6, 0, 44)
scroller.CanvasSize = UDim2.new(0, 0, 0, 0)
scroller.ScrollBarThickness = 6
scroller.BackgroundTransparency = 1
scroller.VerticalScrollBarInset = Enum.ScrollBarInset.Always
scroller.Visible = false
scroller.ZIndex = 50
scroller.Parent = mainFrame

local uiList = Instance.new("UIListLayout", scroller)
uiList.Padding = UDim.new(0,8)
uiList.SortOrder = Enum.SortOrder.LayoutOrder
uiList.HorizontalAlignment = Enum.HorizontalAlignment.Center

-- helper: make small control frames
local function makeControlFrame(height)
    local f = Instance.new("Frame")
    f.Size = UDim2.new(1, -12, 0, height)
    f.BackgroundTransparency = 1
    f.Parent = scroller
    f.ZIndex = 50
    return f
end

-- Toggle creator (syncs with Settings)
local function createToggle(text, settingKey, callback)
    local f = makeControlFrame(36)
    local lbl = Instance.new("TextLabel", f)
    lbl.Size = UDim2.new(0.6, 0, 1, 0)
    lbl.BackgroundTransparency = 1
    lbl.Text = text
    lbl.TextColor3 = Color3.fromRGB(220,220,220)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 14
    lbl.TextXAlignment = Enum.TextXAlignment.Left

    local btn = Instance.new("TextButton", f)
    btn.Size = UDim2.new(0, 60, 0, 26)
    btn.Position = UDim2.new(1, -70, 0, 5)
    btn.BackgroundColor3 = Color3.fromRGB(60,60,60)
    btn.TextColor3 = Color3.fromRGB(200,200,200)
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 14
    btn.Text = Settings[settingKey] and "ON" or "OFF"
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)
    btn.ZIndex = 51

    local state = Settings[settingKey]
    btn.MouseButton1Click:Connect(function()
        state = not state
        Settings[settingKey] = state
        btn.Text = state and "ON" or "OFF"
        btn.BackgroundColor3 = state and Color3.fromRGB(0,180,110) or Color3.fromRGB(60,60,60)
        if callback then pcall(callback, state) end
    end)
    -- init colors
    btn.BackgroundColor3 = state and Color3.fromRGB(0,180,110) or Color3.fromRGB(60,60,60)
    return { frame = f, button = btn, label = lbl }
end

-- Slider creator (simple integer slider)
local function createSlider(text, min, max, default, onChange)
    local f = makeControlFrame(56)
    local lbl = Instance.new("TextLabel", f)
    lbl.Size = UDim2.new(1,0,0,20)
    lbl.BackgroundTransparency = 1
    lbl.Text = text .. ": " .. tostring(default)
    lbl.TextColor3 = Color3.fromRGB(220,220,220)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 13

    local barBg = Instance.new("Frame", f)
    barBg.Size = UDim2.new(1, 0, 0, 8)
    barBg.Position = UDim2.new(0, 0, 1, -14)
    barBg.BackgroundColor3 = Color3.fromRGB(45,45,45)
    barBg.BorderSizePixel = 0
    Instance.new("UICorner", barBg).CornerRadius = UDim.new(1,4)

    local rel = (default - min) / (max - min)
    local fill = Instance.new("Frame", barBg)
    fill.Size = UDim2.new(rel, 0, 1, 0)
    fill.BackgroundColor3 = Color3.fromRGB(100,180,255)
    Instance.new("UICorner", fill).CornerRadius = UDim.new(1,4)

    local knob = Instance.new("TextButton", barBg)
    knob.Size = UDim2.new(0, 18, 0, 18)
    knob.Position = UDim2.new(rel, -9, 0.5, -9)
    knob.Text = ""
    knob.BackgroundColor3 = Color3.fromRGB(245,245,245)
    Instance.new("UICorner", knob).CornerRadius = UDim.new(1,9)
    knob.ZIndex = 52

    local dragging = false
    knob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = true end
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
    end)
    RunService.RenderStepped:Connect(function()
        if dragging and barBg.AbsoluteSize.X > 0 then
            local mx = UserInputService:GetMouseLocation().X
            local relX = math.clamp((mx - barBg.AbsolutePosition.X) / barBg.AbsoluteSize.X, 0, 1)
            fill.Size = UDim2.new(relX, 0, 1, 0)
            knob.Position = UDim2.new(relX, -9, 0.5, -9)
            local val = math.floor(min + (max - min) * relX)
            lbl.Text = text .. ": " .. tostring(val)
            if onChange then pcall(onChange, val) end
        end
    end)
    return { frame = f, label = lbl }
end

-- Expand/collapse behavior
local expanded = false
local function setExpanded(v)
    expanded = v
    if expanded then
        mainFrame.Size = UDim2.new(0, 300, 0, 420)
        scroller.Visible = true
        scroller.CanvasSize = UDim2.new(0, 0, 0, uiList.AbsoluteContentSize.Y + 12)
        expandBtn.Text = "−"
    else
        mainFrame.Size = UDim2.new(0, 300, 0, 80)
        scroller.Visible = false
        expandBtn.Text = "+"
    end
end
expandBtn.MouseButton1Click:Connect(function() setExpanded(not expanded) end)

-- Draggable with clamp to viewport
local draggingWindow = false
local dragStart = Vector2.new()
local frameStart = Vector2.new()
title.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        draggingWindow = true
        dragStart = input.Position
        frameStart = Vector2.new(mainFrame.AbsolutePosition.X, mainFrame.AbsolutePosition.Y)
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then draggingWindow = false end
        end)
    end
end)
title.InputChanged:Connect(function(input)
    if draggingWindow and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - dragStart
        local newPos = frameStart + delta
        local vp = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920,1080)
        local clampedX = math.clamp(newPos.X, 0, math.max(0, vp.X - mainFrame.AbsoluteSize.X))
        local clampedY = math.clamp(newPos.Y, 0, math.max(0, vp.Y - mainFrame.AbsoluteSize.Y))
        mainFrame.Position = UDim2.new(0, clampedX, 0, clampedY)
    end
end)

-- Particles (плавнее)
local particles = {}
local pdata = {}
for i = 1, 36 do
    local p = Instance.new("Frame")
    p.Size = UDim2.new(0, 6, 0, 6)
    p.Position = UDim2.new(math.random(), 0, math.random(), 0)
    p.BackgroundColor3 = Color3.fromRGB(180, 220, 255)
    p.BackgroundTransparency = 0.45
    p.BorderSizePixel = 0
    p.ZIndex = 49
    p.Parent = mainFrame
    Instance.new("UICorner", p).CornerRadius = UDim.new(1, 0)
    particles[#particles+1] = p
    pdata[p] = { px = math.random()*6, py = math.random()*6, speed = 0.3 + math.random()*0.6, phase = math.random()*math.pi*2 }
end
RunService.RenderStepped:Connect(function(dt)
    for _, p in ipairs(particles) do
        local d = pdata[p]
        d.phase = d.phase + dt * d.speed
        local x = 0.08 + math.sin(d.phase * 0.9 + d.px) * 0.36
        local y = 0.14 + math.cos(d.phase * 1.1 + d.py) * 0.36
        p.Position = UDim2.new(x, 0, y, 0)
        p.BackgroundTransparency = 0.35 + 0.15 * math.sin(d.phase*2)
    end
end)

-- Function: safe WorldToViewport -> returns Vector2, onScreen, depth
local function worldToScreen(pos)
    if not camera then return nil, false, 0 end
    local vec, onScreen = camera:WorldToViewportPoint(pos)
    return Vector2.new(vec.X, vec.Y), onScreen, vec.Z
end

-- ESP drawing helpers
local function createQuad()
    local ok, q = pcall(function() return Drawing.new("Quad") end)
    if ok then
        q.Thickness = 2
        q.Transparency = 1
        q.Visible = true
        return q
    end
    return nil
end
local function createText()
    local ok, t = pcall(function() return Drawing.new("Text") end)
    if ok then
        t.Size = 15
        t.Center = true
        t.Outline = true
        t.Visible = true
        return t
    end
    return nil
end

-- Visibility check via Raycast
local function isVisibleToCamera(targetCharacter)
    if not targetCharacter or not camera then return false end
    local targetPart = targetCharacter:FindFirstChild("Head") or targetCharacter.PrimaryPart or targetCharacter:FindFirstChild("HumanoidRootPart")
    if not targetPart then return false end
    local origin = camera.CFrame.Position
    local dir = targetPart.Position - origin
    if dir.Magnitude <= 0.001 then return true end
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = { player.Character }
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    local res = Workspace:Raycast(origin, dir, params)
    if not res then return true end
    if res.Instance and res.Instance:IsDescendantOf(targetCharacter) then
        return true
    end
    return false
end

-- Update ESP (throttled inside)
local lastESP = 0
local espInterval = 0.06
local function updateESP(dt)
    lastESP = lastESP + dt
    if lastESP < espInterval then return end
    lastESP = 0

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr == player then
            if drawings.boxes[plr] then drawings.boxes[plr]:Remove(); drawings.boxes[plr]=nil end
            if drawings.names[plr] then drawings.names[plr]:Remove(); drawings.names[plr]=nil end
            continue
        end
        local char = plr.Character
        if not char then
            if drawings.boxes[plr] then drawings.boxes[plr]:Remove(); drawings.boxes[plr]=nil end
            if drawings.names[plr] then drawings.names[plr]:Remove(); drawings.names[plr]=nil end
            continue
        end
        local head = char:FindFirstChild("Head")
        local root = char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not (head and root and hum and hum.Health > 0) then
            if drawings.boxes[plr] then drawings.boxes[plr]:Remove(); drawings.boxes[plr]=nil end
            if drawings.names[plr] then drawings.names[plr]:Remove(); drawings.names[plr]=nil end
            continue
        end

        local screenHead, onScreenHead, zHead = worldToScreen(head.Position + Vector3.new(0,0.5,0))
        local screenLeg, onScreenLeg, zLeg = worldToScreen(root.Position - Vector3.new(0,3,0))
        if not onScreenHead or zHead <= 0 or not onScreenLeg or zLeg <= 0 then
            if drawings.boxes[plr] then drawings.boxes[plr]:Remove(); drawings.boxes[plr]=nil end
            if drawings.names[plr] then drawings.names[plr]:Remove(); drawings.names[plr]=nil end
            continue
        end

        -- visibility
        local dir = head.Position - camera.CFrame.Position
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = { player.Character }
        params.FilterType = Enum.RaycastFilterType.Blacklist
        params.IgnoreWater = true
        local res = Workspace:Raycast(camera.CFrame.Position, dir, params)
        local visible = (not res) or (res.Instance and res.Instance:IsDescendantOf(char))

        local color = visible and Color3.fromRGB(0,255,120) or Color3.fromRGB(255,80,80)

        -- box
        if not drawings.boxes[plr] then drawings.boxes[plr] = createQuad() end
        local box = drawings.boxes[plr]
        if box then
            local height = math.abs(screenHead.Y - screenLeg.Y)
            local width = math.max(12, height * 0.45)
            box.PointA = Vector2.new(screenHead.X - width/2, screenHead.Y)
            box.PointB = Vector2.new(screenHead.X + width/2, screenHead.Y)
            box.PointC = Vector2.new(screenHead.X + width/2, screenLeg.Y)
            box.PointD = Vector2.new(screenHead.X - width/2, screenLeg.Y)
            box.Color = color
            box.Visible = true
        end

        -- name text
        if not drawings.names[plr] then drawings.names[plr] = createText() end
        local txt = drawings.names[plr]
        if txt and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local dist = math.floor((player.Character.HumanoidRootPart.Position - root.Position).Magnitude)
            txt.Text = plr.Name .. " [" .. tostring(dist) .. "m]"
            txt.Position = Vector2.new(screenHead.X, screenHead.Y - 18)
            txt.Color = color
            txt.Visible = true
        end
    end
end

-- getClosest target inside FOV circle (screen-space distance from center)
local function getClosestTargetInFOV()
    local best = nil
    local bestDist = math.huge
    local center = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)
    local radius = (Settings.AimbotFOV/2) * (camera.ViewportSize.Y / math.tan(math.rad(camera.FieldOfView/2)))
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr == player then continue end
        if Settings.TeamCheck and plr.Team == player.Team then continue end
        local char = plr.Character
        local head = char and char:FindFirstChild("Head")
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        local root = char and (char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart)
        if not (char and head and hum and hum.Health > 0 and root) then continue end

        local screenHead, onScreen, z = worldToScreen(head.Position + Vector3.new(0,0.5,0))
        if not onScreen or z <= 0 then continue end

        -- LOS check
        local dir = head.Position - camera.CFrame.Position
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = { player.Character }
        params.FilterType = Enum.RaycastFilterType.Blacklist
        params.IgnoreWater = true
        local res = Workspace:Raycast(camera.CFrame.Position, dir, params)
        if res and not res.Instance:IsDescendantOf(char) then continue end

        local d = (screenHead - center).Magnitude
        if d <= radius and d < bestDist then
            bestDist = d
            best = head
        end
    end
    return best
end

-- isAimHeld supports MouseButton and KeyCode binds
local function isAimHeld()
    if not aimBind or not aimBind.InputType then return false end
    local t = aimBind.InputType
    if t == Enum.UserInputType.MouseButton1 or t == Enum.UserInputType.MouseButton2 or t == Enum.UserInputType.MouseButton3 then
        local ok, pressed = pcall(function() return UserInputService:IsMouseButtonPressed(t) end)
        return ok and pressed
    elseif t == Enum.UserInputType.Keyboard then
        if aimBind.KeyCode and aimBind.KeyCode ~= Enum.KeyCode.Unknown then
            return UserInputService:IsKeyDown(aimBind.KeyCode)
        end
    end
    return false
end

-- Aimbot: создаём/удаляем FOV drawing и запускаем RenderStepped
local function startAimbot()
    if aimbotConnection then aimbotConnection:Disconnect(); aimbotConnection = nil end
    local ok, circ = pcall(function() return Drawing.new("Circle") end)
    if ok and circ then
        drawings.fov = circ
        circ.Thickness = 2
        circ.Color = Color3.fromRGB(255,120,100)
        circ.NumSides = 120
        circ.Visible = true
    else
        drawings.fov = nil
    end

    aimbotConnection = RunService.RenderStepped:Connect(function(dt)
        if drawings.fov then
            local radius = (Settings.AimbotFOV/2) * (camera.ViewportSize.Y / math.tan(math.rad(camera.FieldOfView/2)))
            drawings.fov.Radius = radius
            drawings.fov.Position = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)
            drawings.fov.Visible = Settings.Aimbot
        end

        if not Settings.Aimbot then return end

        if Settings.AimbotHoldMode then
            if not isAimHeld() then return end
        else
            -- toggle mode: if not held, still allow (Settings.Aimbot true => active)
        end

        local target = getClosestTargetInFOV()
        if not target then return end

        local targetPos = target.Position + Vector3.new(0, 0.2, 0)
        local camPos = camera.CFrame.Position
        local goal = CFrame.new(camPos, targetPos)
        local smooth = math.clamp(Settings.AimbotSmooth or 0.15, 0, 1)
        local alpha = 1 - math.exp(-smooth * 60 * dt)
        camera.CFrame = camera.CFrame:Lerp(goal, alpha)
    end)
end

local function stopAimbot()
    if aimbotConnection then aimbotConnection:Disconnect(); aimbotConnection = nil end
    if drawings.fov then pcall(function() drawings.fov:Remove() end); drawings.fov = nil end
end

-- Toggle functions
local function toggleESP(v)
    Settings.ESP = v
    if not v then
        for k,_ in pairs(drawings.boxes) do if drawings.boxes[k] then drawings.boxes[k]:Remove(); drawings.boxes[k]=nil end end
        for k,_ in pairs(drawings.names) do if drawings.names[k] then drawings.names[k]:Remove(); drawings.names[k]=nil end end
    end
end

local function toggleAimbotState(v)
    Settings.Aimbot = v
    if v then startAimbot() else stopAimbot() end
end

local function toggleNoclip(v)
    Settings.Noclip = v
    if noclipConnection then noclipConnection:Disconnect(); noclipConnection = nil end
    if v then
        noclipConnection = RunService.Stepped:Connect(function()
            if player.Character then
                for _, part in ipairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        if part.CanCollide then pcall(function() part.CanCollide = false end) end
                    end
                end
            end
        end)
    end
end

local function toggleFly(v)
    Settings.Fly = v
    if flyBodyVelocity then flyBodyVelocity:Destroy(); flyBodyVelocity = nil end
    if v then
        local root = player.Character and (player.Character:FindFirstChild("HumanoidRootPart") or player.Character.PrimaryPart)
        if root then
            flyBodyVelocity = Instance.new("BodyVelocity")
            flyBodyVelocity.MaxForce = Vector3.new(1e5,1e5,1e5)
            flyBodyVelocity.Velocity = Vector3.new(0,0,0)
            flyBodyVelocity.Parent = root
        end
    end
end

-- UI: добавляем контролы в scroller
createToggle("ESP (Green = visible)", "ESP", function(v) toggleESP(v) end)
createToggle("Aimbot (Hold mode)", "Aimbot", function(v) toggleAimbotState(v) end)

-- Aimbot Hold/Toggle switch
do
    local f = makeControlFrame(36)
    local lbl = Instance.new("TextLabel", f)
    lbl.Size = UDim2.new(0.6,0,1,0)
    lbl.BackgroundTransparency = 1
    lbl.Text = "Hold Mode (if on — hold bind, else toggle)"
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.TextColor3 = Color3.fromRGB(220,220,220)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 13

    local btn = Instance.new("TextButton", f)
    btn.Size = UDim2.new(0, 60, 0, 26)
    btn.Position = UDim2.new(1, -70, 0, 5)
    btn.Text = Settings.AimbotHoldMode and "ON" or "OFF"
    btn.BackgroundColor3 = Settings.AimbotHoldMode and Color3.fromRGB(0,180,110) or Color3.fromRGB(60,60,60)
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 14
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)
    btn.MouseButton1Click:Connect(function()
        Settings.AimbotHoldMode = not Settings.AimbotHoldMode
        btn.Text = Settings.AimbotHoldMode and "ON" or "OFF"
        btn.BackgroundColor3 = Settings.AimbotHoldMode and Color3.fromRGB(0,180,110) or Color3.fromRGB(60,60,60)
    end)
end

-- Bind UI (кнопка, ждёт следующего InputBegan чтобы установить bind)
do
    local f = makeControlFrame(36)
    local lbl = Instance.new("TextLabel", f)
    lbl.Size = UDim2.new(0.4,0,1,0)
    lbl.BackgroundTransparency = 1
    lbl.Text = "Aimbot bind:"
    lbl.TextColor3 = Color3.fromRGB(220,220,220)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 13
    lbl.TextXAlignment = Enum.TextXAlignment.Left

    local btn = Instance.new("TextButton", f)
    btn.Size = UDim2.new(0, 140, 0, 26)
    btn.Position = UDim2.new(1, -150, 0, 5)
    btn.Text = "MouseButton2 (RMB)"
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 14
    btn.BackgroundColor3 = Color3.fromRGB(60,60,60)
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)

    btn.MouseButton1Click:Connect(function()
        bindingMode = true
        btn.Text = "Press any key/button..."
        btn.BackgroundColor3 = Color3.fromRGB(100,100,100)
        -- waiting handled in global InputBegan below
    end)

    -- when bind changed, update text
    local function updateBindText()
        if not aimBind or not aimBind.InputType then btn.Text = "None"; return end
        if aimBind.InputType == Enum.UserInputType.Keyboard and aimBind.KeyCode then
            btn.Text = tostring(aimBind.KeyCode):gsub("Enum.KeyCode.","")
        else
            btn.Text = tostring(aimBind.InputType):gsub("Enum.UserInputType.","")
        end
        btn.BackgroundColor3 = Color3.fromRGB(60,60,60)
    end
    updateBindText()

    -- store update function
    scroller:GetPropertyChangedSignal("CanvasSize"):Connect(function()
        scroller.CanvasSize = UDim2.new(0,0,0,uiList.AbsoluteContentSize.Y + 12)
    end)
end

-- global InputBegan: if bindingMode -> capture bind
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if bindingMode then
        aimBind.InputType = input.UserInputType
        aimBind.KeyCode = input.KeyCode ~= Enum.KeyCode.Unknown and input.KeyCode or nil
        bindingMode = false
        -- update bind button text (search it)
        for _, child in ipairs(scroller:GetChildren()) do
            if child:IsA("Frame") then
                local tb = child:FindFirstChildOfClass("TextButton")
                if tb and (tb.Text == "Press any key/button..." or tb.Text:match("Mouse") ) then
                    tb.Text = (aimBind.InputType == Enum.UserInputType.Keyboard and tostring(aimBind.KeyCode):gsub("Enum.KeyCode.","")) or tostring(aimBind.InputType):gsub("Enum.UserInputType.","")
                    tb.BackgroundColor3 = Color3.fromRGB(60,60,60)
                    break
                end
            end
        end
        return
    end
end)

-- Sliders
createSlider("Walk Speed", 16, 500, Settings.WalkSpeed or 16, function(v)
    Settings.WalkSpeed = v
    if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
        player.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = v
    end
end)
createSlider("Fly Speed", 1, 200, Settings.FlySpeed, function(v) Settings.FlySpeed = v end)
createSlider("Aimbot FOV", 30, 360, Settings.AimbotFOV, function(v) Settings.AimbotFOV = v end)
createSlider("Aimbot Smooth (smaller = faster)", 5, 50, math.floor((Settings.AimbotSmooth or 0.15)*100), function(v)
    Settings.AimbotSmooth = v/100
end)

-- auto update scroller canvas size
scroller.CanvasSize = UDim2.new(0, 0, 0, uiList.AbsoluteContentSize.Y + 12)
uiList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    scroller.CanvasSize = UDim2.new(0, 0, 0, uiList.AbsoluteContentSize.Y + 12)
end)

-- Main loop: update ESP and fly behavior
RunService.RenderStepped:Connect(function(dt)
    if Settings.ESP then updateESP(dt) end

    -- Fly movement
    if Settings.Fly and flyBodyVelocity then
        local root = player.Character and (player.Character:FindFirstChild("HumanoidRootPart") or player.Character.PrimaryPart)
        if root then
            local move = Vector3.new()
            local cf = camera.CFrame
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then move += cf.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then move -= cf.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then move -= cf.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then move += cf.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then move += Vector3.new(0,1,0) end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then move -= Vector3.new(0,1,0) end
            if move.Magnitude > 0 then move = move.Unit else move = Vector3.new(0,0,0) end
            flyBodyVelocity.Velocity = move * (Settings.FlySpeed or 50)
        end
    end
end)

-- Start/stop aimbot depending on Settings and hold-mode
-- ensure start if toggled on
local function ensureAimbotState()
    if Settings.Aimbot then startAimbot() else stopAimbot() end
end

-- Hook Settings toggles via local helper: find toggle by label text and set initial state
for _, child in ipairs(scroller:GetChildren()) do
    if child:IsA("Frame") then
        local lbl = child:FindFirstChildOfClass("TextLabel")
        local btn = child:FindFirstChildOfClass("TextButton")
        if lbl and btn then
            local keyText = lbl.Text
            if keyText:match("ESP") then
                btn.Text = Settings.ESP and "ON" or "OFF"
            elseif keyText:match("Aimbot %- Hold") or keyText:match("Aimbot %(") then
                btn.Text = Settings.Aimbot and "ON" or "OFF"
            end
        end
    end
end

-- Cleanup on leave
Players.PlayerRemoving:Connect(function(pl)
    if drawings.boxes[pl] then drawings.boxes[pl]:Remove(); drawings.boxes[pl]=nil end
    if drawings.names[pl] then drawings.names[pl]:Remove(); drawings.names[pl]=nil end
end)
player.CharacterRemoving:Connect(function()
    for k,_ in pairs(drawings.boxes) do if drawings.boxes[k] then drawings.boxes[k]:Remove(); drawings.boxes[k]=nil end end
    for k,_ in pairs(drawings.names) do if drawings.names[k] then drawings.names[k]:Remove(); drawings.names[k]=nil end end
end)

-- Initialization
setExpanded(false)
print("Salt v5 UI loaded — протестируйте. По умолчанию Aimbot bind = MouseButton2 (RMB).")
