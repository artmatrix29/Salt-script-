-- Salt V5 — ESP (видимость), Aimbot (цель: ближайшая видимая), Fly, TP на Z, улучшенный UI
-- Замените старый файл в репозитории на этот. Тестируйте в Roblox Studio как LocalScript.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local mouse = LocalPlayer:GetMouse()
local camera = Workspace.CurrentCamera

-- Настройки
local Settings = {
    Fly = false,
    FlySpeed = 100,
    Noclip = false,
    WalkSpeed = 16,
    InfiniteJump = false,
    ESP = false,
    ClickTeleport = false, -- если true, клавиша Z телепортирует к курсору
    Aimbot = false,
    AimbotFOV = 120, -- градусы
    AimbotSmooth = 0.15, -- 0..1, чем меньше — быстрее
    TeamCheck = true
}

-- Внутренние
local connections = {}
local espData = {} -- таблица per-player: {billboard, selectionBox, lastDistance, visible}
local currentAimbotTarget = nil
local originalCameraType = camera.CameraType
local aimbotActive = false

local function addConnection(event, fn)
    local c = event:Connect(fn)
    table.insert(connections, c)
    return c
end
local function disconnectAll()
    for _, c in ipairs(connections) do
        if c and c.Connected then pcall(function() c:Disconnect() end) end
    end
    connections = {}
end

-- Утилиты
local function safeCharacter(player)
    return player and player.Character
end

local function getTargetPart(char)
    if not char then return nil end
    local head = char:FindFirstChild("Head")
    if head and head:IsA("BasePart") then return head end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if hrp and hrp:IsA("BasePart") then return hrp end
    -- fallback: first available BasePart
    for _, v in ipairs(char:GetChildren()) do
        if v:IsA("BasePart") then return v end
    end
    return nil
end

-- Проверка видимости цели: true если первый хит raycast'а — часть цели
local function isVisibleToCamera(targetChar)
    if not targetChar then return false end
    local targetPart = getTargetPart(targetChar)
    if not targetPart then return false end
    local origin = camera.CFrame.Position
    local direction = (targetPart.Position - origin)
    if direction.Magnitude <= 0.001 then return true end

    local params = RaycastParams.new()
    params.FilterDescendantsInstances = { LocalPlayer.Character } -- не мешаем себе
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true

    local result = Workspace:Raycast(origin, direction, params)
    if not result then
        -- нет хитa — возможно далеко/ничего на пути => считаем видимым
        return true
    end
    local inst = result.Instance
    if inst and inst:IsDescendantOf(targetChar) then
        return true
    end
    return false
end

-- ESP: создаём или обновляем визуальные элементы для игрока
local function ensureESPForPlayer(pl)
    if espData[pl] then return espData[pl] end
    local data = {}
    data.billboard = nil
    data.selection = nil
    data.visible = false
    data.lastDistance = 0
    espData[pl] = data
    return data
end

local function clearESPForPlayer(pl)
    local d = espData[pl]
    if not d then return end
    if d.billboard and d.billboard.Parent then d.billboard:Destroy() end
    if d.selection and d.selection.Parent then d.selection:Destroy() end
    espData[pl] = nil
end

local function updateESPAll()
    -- создаём/обновляем каждый игрок, но только если Settings.ESP
    if not Settings.ESP then
        -- очистка
        for pl, _ in pairs(espData) do
            clearESPForPlayer(pl)
        end
        return
    end

    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChildWhichIsA then
            local humanoid = pl.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local targetPart = getTargetPart(pl.Character)
                if targetPart then
                    local data = ensureESPForPlayer(pl)

                    -- Billboard
                    if not data.billboard or not data.billboard.Parent then
                        local bg = Instance.new("BillboardGui")
                        bg.Name = "SaltESP"
                        bg.Adornee = targetPart
                        bg.Size = UDim2.new(0,120,0,40)
                        bg.StudsOffset = Vector3.new(0, 2.5, 0)
                        bg.AlwaysOnTop = true
                        bg.Parent = targetPart

                        local label = Instance.new("TextLabel", bg)
                        label.Size = UDim2.new(1,0,1,0)
                        label.BackgroundTransparency = 1
                        label.TextScaled = true
                        label.Font = Enum.Font.SourceSansBold
                        label.TextColor3 = Color3.new(1,1,1)
                        label.TextStrokeTransparency = 0.6
                        label.Name = "Label"
                        data.billboard = bg
                    end

                    -- SelectionBox (обводка)
                    if not data.selection or not data.selection.Parent then
                        local sel = Instance.new("SelectionBox")
                        sel.Name = "SaltSelection"
                        sel.Adornee = targetPart
                        sel.Parent = targetPart -- parent to part (works on client)
                        sel.LineThickness = 0.05
                        sel.SurfaceTransparency = 1
                        data.selection = sel
                    end

                    -- обновление текста и цвета
                    local dist = math.floor((camera.CFrame.Position - targetPart.Position).Magnitude)
                    data.lastDistance = dist
                    local vis = isVisibleToCamera(pl.Character)
                    data.visible = vis

                    if data.billboard and data.billboard:FindFirstChild("Label") then
                        local label = data.billboard.Label
                        label.Text = pl.Name .. " [" .. tostring(dist) .. "m]"
                        -- цвет текста можно менять, но игрок просил обводку менять
                    end
                    if data.selection then
                        data.selection.Color3 = vis and Color3.fromRGB(0, 255, 120) or Color3.fromRGB(255, 80, 80)
                    end
                else
                    -- нет подходящей части — очистим
                    clearESPForPlayer(pl)
                end
            else
                -- мёртв/нет гуманоид — очистим
                clearESPForPlayer(pl)
            end
        else
            clearESPForPlayer(pl)
        end
    end
end

-- Aimbot: выбирает ближайшую видимую (visible=true) цель и плавно наводит камеру
local function findAimbotTarget()
    local best = nil
    local bestDist = math.huge
    for pl, d in pairs(espData) do
        if pl and pl.Character and pl.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = pl.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                if d.visible then
                    -- берём расстояние до камеры (можно заменить на расстояние до персонажа)
                    local targetPart = getTargetPart(pl.Character)
                    if not targetPart then goto continue end
                    local dist = (camera.CFrame.Position - targetPart.Position).Magnitude
                    if dist < bestDist then
                        bestDist = dist
                        best = {player = pl, part = targetPart, dist = dist}
                    end
                end
            end
        end
        ::continue::
    end
    return best
end

local function enableAimbot(enable)
    if enable and not aimbotActive then
        originalCameraType = camera.CameraType
        camera.CameraType = Enum.CameraType.Scriptable
        aimbotActive = true
    elseif not enable and aimbotActive then
        -- возвращаем камеру к исходному типу
        camera.CameraType = originalCameraType or Enum.CameraType.Custom
        aimbotActive = false
        currentAimbotTarget = nil
    end
end

-- Главный цикл аимбота — выполняется каждое кадро, плавно поворачивает камеру
addConnection(RunService.RenderStepped, function(dt)
    -- ESP обновляем медленнее (в другом таймере), но для корректности используем данные espData здесь
    if Settings.Aimbot then
        enableAimbot(true)
        -- находим цель, если нужно обновить
        if not currentAimbotTarget or not currentAimbotTarget.player or not espData[currentAimbotTarget.player] or not espData[currentAimbotTarget.player].visible then
            local found = findAimbotTarget()
            if found then
                currentAimbotTarget = found
            else
                currentAimbotTarget = nil
            end
        end

        if currentAimbotTarget and currentAimbotTarget.part and currentAimbotTarget.player then
            local targetPos = currentAimbotTarget.part.Position
            local camPos = camera.CFrame.Position
            local goalCFrame = CFrame.new(camPos, targetPos)
            local smooth = math.clamp(Settings.AimbotSmooth or 0.15, 0, 1)
            camera.CFrame = camera.CFrame:Lerp(goalCFrame, 1 - math.exp(-smooth * 60 * dt)) -- экспоненциальный подход для стабильности
        end
    else
        -- отключаем аимбот если не нужен
        if aimbotActive then enableAimbot(false) end
    end
end)

-- Fly: простая реализация (удержание позиции с возможностью перемещения)
do
    local bodyVel = nil
    local bodyGyro = nil
    local flyConnection
    local function startFly()
        if not LocalPlayer.Character then return end
        local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        if flyConnection then flyConnection:Disconnect(); flyConnection = nil end
        bodyVel = Instance.new("BodyVelocity")
        bodyVel.MaxForce = Vector3.new(1e5, 1e5, 1e5)
        bodyVel.P = 1e4
        bodyVel.Velocity = Vector3.new(0,0,0)
        bodyVel.Parent = hrp
        flyConnection = RunService.Heartbeat:Connect(function()
            if not hrp or not bodyVel then return end
            local move = Vector3.new(0,0,0)
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then move = move + camera.CFrame.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then move = move - camera.CFrame.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then move = move - camera.CFrame.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then move = move + camera.CFrame.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then move = move + Vector3.new(0,1,0) end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.C) then move = move - Vector3.new(0,1,0) end
            move = move.Unit ~= move.Unit and Vector3.new(0,0,0) or move.Unit
            local speed = Settings.FlySpeed or 100
            bodyVel.Velocity = move * speed
        end)
    end
    local function stopFly()
        if flyConnection then flyConnection:Disconnect(); flyConnection = nil end
        if bodyVel and bodyVel.Parent then bodyVel:Destroy() end
        bodyVel = nil
    end

    -- слежение за Settings.Fly
    addConnection(RunService.Heartbeat, function()
        if Settings.Fly then
            if not bodyVel then startFly() end
        else
            if bodyVel then stopFly() end
        end
    end)
end

-- TP на Z: если Settings.ClickTeleport true и нажата Z — телепорт к mouse.Hit
addConnection(UserInputService.InputBegan, function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.Z and Settings.ClickTeleport then
            local targetPos = mouse.Hit and mouse.Hit.p
            if targetPos and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos + Vector3.new(0,3,0))
            end
        end
    end
end)

-- Обновление ESP периодически (чтобы не Raycast'ить каждый кадр сильно)
do
    local last = 0
    local interval = 0.5 -- раз в 0.5 сек
    addConnection(RunService.Heartbeat, function(dt)
        last = last + dt
        if last >= interval then
            last = 0
            if Settings.ESP then
                -- обновляем данные (видимость + GUI)
                updateESPAll()
            else
                -- очищаем при отключении
                for pl, _ in pairs(espData) do clearESPForPlayer(pl) end
            end
        end
    end)
end

-- WalkSpeed при входе персонажа
LocalPlayer.CharacterAdded:Connect(function(char)
    spawn(function()
        local hum = char:WaitForChild("Humanoid")
        hum.WalkSpeed = Settings.WalkSpeed or 16
    end)
end)

-- Infinite Jump
addConnection(UserInputService.JumpRequest, function()
    if Settings.InfiniteJump then
        local char = LocalPlayer.Character
        if char and char:FindFirstChildOfClass("Humanoid") then
            char:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)

-- Нoclip: простой - отключаем коллизии частей персонажа
do
    local noclipConn
    addConnection(RunService.Heartbeat, function()
        if Settings.Noclip then
            if not noclipConn then
                noclipConn = RunService.Stepped:Connect(function()
                    local char = LocalPlayer.Character
                    if not char then return end
                    for _, part in ipairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end)
                table.insert(connections, noclipConn)
            end
        else
            if noclipConn and noclipConn.Connected then
                noclipConn:Disconnect()
                noclipConn = nil
            end
        end
    end)
end

-- Очистка ESP при выходе игрока из игры или при смене статуса
Players.PlayerRemoving:Connect(function(pl)
    clearESPForPlayer(pl)
end)

-- UI: (предполагается, что у вас уже есть меню — если хотите, могу интегрировать с вашим UI)
-- Важно: чтобы аимбот корректно работал, оставьте доступ к камере (Scriptable переключается во время аима).

print("Salt V5 — ESP/Aimbot/Fly/TP (Z) loaded. Проверьте настройки в таблице Settings. Для доработок напишите, какие именно механики хотите улучшить.")
