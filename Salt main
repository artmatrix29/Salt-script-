-- Salt Personal Cheat Menu v5 (Aimbot на зелёных + FOV + Smooth)
-- Только для личного использования | Roblox Luau | 2026

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()
local camera = Workspace.CurrentCamera

-- Настройки
local Settings = {
    Fly = false,
    FlySpeed = 50,
    Noclip = false,
    Speed = 16,
    InfiniteJump = false,
    ESP = false,
    Aimbot = false,
    AimbotFOV = 120,
    AimbotSmooth = 0.15,  -- 0.1 = быстро, 0.3 = очень плавно
    TeamCheck = true      -- не целить тиммейтов
}

local flyBodyVelocity = nil
local noclipConnection = nil
local espConnection = nil
local aimbotConnection = nil
local drawings = {boxes = {}, names = {}, fovCircle = nil}
local aimTarget = nil

-- ScreenGui
local sg = Instance.new("ScreenGui")
sg.Name = "SaltGUI"
sg.ResetOnSpawn = false
sg.Parent = game:GetService("CoreGui")

-- Main Frame (draggable)
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 260, 0, 520)
mainFrame.Position = UDim2.new(0, 15, 0, 15)
mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = sg
Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 12)

-- Shadow
local shadow = Instance.new("Frame")
shadow.Size = UDim2.new(1, 6, 1, 6)
shadow.Position = UDim2.new(0, -3, 0, -3)
shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
shadow.BackgroundTransparency = 0.6
shadow.ZIndex = -1
shadow.Parent = mainFrame
Instance.new("UICorner", shadow).CornerRadius = UDim.new(0, 15)

-- Title (drag handle)
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 45)
title.BackgroundTransparency = 1
title.Text = "Salt v5 (Aimbot)"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextSize = 28
title.Font = Enum.Font.GothamBold
title.TextXAlignment = Enum.TextXAlignment.Center
title.Parent = mainFrame

-- Draggable
local dragging, dragStart, startPos
title.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
    end
end)
title.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - dragStart
        mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
end)

-- Particles (плавные точки)
local particles = {}
local particleData = {}
for i = 1, 80 do
    local part = Instance.new("Frame")
    part.Size = UDim2.new(0, 4, 0, 4)
    part.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    part.BackgroundTransparency = 0.5
    part.BorderSizePixel = 0
    part.ZIndex = 1
    part.Parent = mainFrame
    Instance.new("UICorner", part).CornerRadius = UDim.new(1, 0)
    part.Position = UDim2.new(math.random(), 0, math.random(), 0)
    table.insert(particles, part)
    particleData[part] = {
        phaseX = math.random()*math.pi*2,
        phaseY = math.random()*math.pi*2,
        speedX = (math.random()-0.5)*0.002,
        speedY = (math.random()-0.5)*0.002
    }
end
RunService.RenderStepped:Connect(function()
    for _, part in ipairs(particles) do
        local d = particleData[part]
        d.phaseX += d.speedX
        d.phaseY += d.speedY
        local x = 0.1 + math.sin(d.phaseX)*0.4
        local y = 0.1 + math.cos(d.phaseY)*0.4
        part.Position = UDim2.new(x, 0, y, 0)
        part.BackgroundTransparency = 0.3 + math.sin(tick()*4 + d.phaseX)*0.3
    end
end)

-- Toggle
local yOffset = 55
local function createToggle(name, callback)
    local toggleFrame = Instance.new("Frame")
    toggleFrame.Size = UDim2.new(1, -20, 0, 35)
    toggleFrame.Position = UDim2.new(0, 10, 0, yOffset)
    toggleFrame.BackgroundTransparency = 1
    toggleFrame.Parent = mainFrame
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.75, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = name
    label.TextColor3 = Color3.fromRGB(220, 220, 220)
    label.TextSize = 16
    label.Font = Enum.Font.GothamSemibold
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = toggleFrame
    
    local toggleBtn = Instance.new("TextButton")
    toggleBtn.Size = UDim2.new(0, 45, 0, 25)
    toggleBtn.Position = UDim2.new(1, -55, 0, 5)
    toggleBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    toggleBtn.Text = "OFF"
    toggleBtn.TextColor3 = Color3.fromRGB(180, 180, 180)
    toggleBtn.Font = Enum.Font.GothamBold
    toggleBtn.TextSize = 14
    toggleBtn.Parent = toggleFrame
    Instance.new("UICorner", toggleBtn).CornerRadius = UDim.new(0, 8)
    
    local enabled = false
    toggleBtn.MouseButton1Click:Connect(function()
        enabled = not enabled
        toggleBtn.Text = enabled and "ON" or "OFF"
        toggleBtn.BackgroundColor3 = enabled and Color3.fromRGB(0, 200, 120) or Color3.fromRGB(50, 50, 50)
        toggleBtn.TextColor3 = enabled and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(180, 180, 180)
        callback(enabled)
    end)
    
    yOffset = yOffset + 45
end

-- Slider
local function createSlider(name, min, max, default, callback)
    local sliderFrame = Instance.new("Frame")
    sliderFrame.Size = UDim2.new(1, -20, 0, 55)
    sliderFrame.Position = UDim2.new(0, 10, 0, yOffset)
    sliderFrame.BackgroundTransparency = 1
    sliderFrame.Parent = mainFrame
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 0, 25)
    label.BackgroundTransparency = 1
    label.Text = name .. ": " .. default
    label.TextColor3 = Color3.fromRGB(220, 220, 220)
    label.TextSize = 15
    label.Font = Enum.Font.Gotham
    label.Parent = sliderFrame
    
    local barBg = Instance.new("Frame")
    barBg.Size = UDim2.new(1, 0, 0, 6)
    barBg.Position = UDim2.new(0, 0, 1, -10)
    barBg.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    barBg.BorderSizePixel = 0
    barBg.Parent = sliderFrame
    Instance.new("UICorner", barBg).CornerRadius = UDim.new(1, 0)
    
    local barFill = Instance.new("Frame")
    barFill.Size = UDim2.new((default - min) / (max - min), 0, 1, 0)
    barFill.BackgroundColor3 = Color3.fromRGB(100, 200, 255)
    barFill.BorderSizePixel = 0
    barFill.Parent = barBg
    Instance.new("UICorner", barFill).CornerRadius = UDim.new(1, 0)
    
    local knob = Instance.new("Frame")
    knob.Size = UDim2.new(0, 20, 0, 20)
    knob.Position = UDim2.new((default - min) / (max - min), -10, 0.5, -10)
    knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    knob.BorderSizePixel = 0
    knob.Parent = barBg
    Instance.new("UICorner", knob).CornerRadius = UDim.new(1, 0)
    
    local dragging = false
    knob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = true end
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
    end)
    
    RunService.RenderStepped:Connect(function()
        if dragging and barBg.AbsoluteSize.X > 0 then
            local mousePos = UserInputService:GetMouseLocation()
            local relX = math.clamp((mousePos.X - barBg.AbsolutePosition.X) / barBg.AbsoluteSize.X, 0, 1)
            local val = math.floor(min + (max - min) * relX)
            knob.Position = UDim2.new(relX, -10, 0.5, -10)
            barFill.Size = UDim2.new(relX, 0, 1, 0)
            label.Text = name .. ": " .. val
            callback(val)
        end
    end)
    
    yOffset = yOffset + 65
end

-- Fly (как в v4)
local function toggleFly(enabled)
    Settings.Fly = enabled
    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    if enabled then
        flyBodyVelocity = Instance.new("BodyVelocity")
        flyBodyVelocity.MaxForce = Vector3.new(1e5, 1e5, 1e5)
        flyBodyVelocity.Velocity = Vector3.new(0,0.1,0)
        flyBodyVelocity.Parent = root
    else
        if flyBodyVelocity then flyBodyVelocity:Destroy() flyBodyVelocity = nil end
    end
end

RunService.RenderStepped:Connect(function()
    if Settings.Fly and flyBodyVelocity then
        local root = player.Character and player.Character.HumanoidRootPart
        if not root then return end
        local move = Vector3.new()
        local camCFrame = camera.CFrame
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then move += camCFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then move -= camCFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then move -= camCFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then move += camCFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.E) or UserInputService:IsKeyDown(Enum.KeyCode.Space) then move += Vector3.new(0,1,0) end
        if UserInputService:IsKeyDown(Enum.KeyCode.Q) or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then move -= Vector3.new(0,1,0) end
        if move.Magnitude > 0 then move = move.Unit end
        flyBodyVelocity.Velocity = move * Settings.FlySpeed
        root.AssemblyAngularVelocity = Vector3.new(0,0,0) -- no rotate
    end
end)

-- Noclip (как раньше)
local function toggleNoclip(enabled)
    Settings.Noclip = enabled
    if noclipConnection then noclipConnection:Disconnect() end
    if enabled then
        noclipConnection = RunService.Stepped:Connect(function()
            if player.Character then
                for _, part in player.Character:GetDescendants() do
                    if part:IsA("BasePart") then part.CanCollide = false end
                end
            end
        end)
    end
end

-- ESP + Aimbot helper (находим ближайшего зелёного)
local function getClosestGreen()
    local closest = nil
    local minDist = math.huge
    local mousePos = Vector2.new(mouse.X, mouse.Y)
    
    for _, plr in Players:GetPlayers() do
        if plr == player or not plr.Character then continue end
        local root = plr.Character:FindFirstChild("HumanoidRootPart")
        local head = plr.Character:FindFirstChild("Head")
        local hum = plr.Character:FindFirstChild("Humanoid")
        if not (root and head and hum and hum.Health > 0) then continue end
        
        if Settings.TeamCheck and plr.Team == player.Team then continue end
        
        local headPos, onScreen = camera:WorldToViewportPoint(head.Position)
        if not onScreen then continue end
        
        -- LOS check (как в ESP)
        local dir = (head.Position - camera.CFrame.Position)
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {player.Character, plr.Character}
        params.FilterType = Enum.RaycastFilterType.Blacklist
        local result = Workspace:Raycast(camera.CFrame.Position, dir, params)
        if result then continue end  -- за стеной
        
        local screenDist = (Vector2.new(headPos.X, headPos.Y) - mousePos).Magnitude
        if screenDist < minDist and screenDist < (Settings.AimbotFOV / 2 * camera.ViewportSize.Y / math.tan(math.rad(camera.FieldOfView / 2))) then
            minDist = screenDist
            closest = head
        end
    end
    return closest
end

-- Aimbot toggle + FOV circle
local function toggleAimbot(enabled)
    Settings.Aimbot = enabled
    if aimbotConnection then aimbotConnection:Disconnect() end
    
    if not enabled then
        if drawings.fovCircle then drawings.fovCircle:Remove() drawings.fovCircle = nil end
        return
    end
    
    -- FOV круг
    drawings.fovCircle = Drawing.new("Circle")
    drawings.fovCircle.Thickness = 2
    drawings.fovCircle.Color = Color3.fromRGB(255, 100, 100)
    drawings.fovCircle.Transparency = 0.8
    drawings.fovCircle.NumSides = 100
    drawings.fovCircle.Radius = Settings.AimbotFOV / 2 * (camera.ViewportSize.Y / math.tan(math.rad(camera.FieldOfView / 2)))
    drawings.fovCircle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    drawings.fovCircle.Visible = true
    
    -- Aimbot logic (Right Mouse hold)
    aimbotConnection = RunService.RenderStepped:Connect(function()
        drawings.fovCircle.Radius = Settings.AimbotFOV / 2 * (camera.ViewportSize.Y / math.tan(math.rad(camera.FieldOfView / 2)))
        
        if not UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
            aimTarget = nil
            return
        end
        
        aimTarget = getClosestGreen()
        if not aimTarget then return end
        
        local targetPos = aimTarget.Position + Vector3.new(0, 0.2, 0)  -- чуть выше головы
        local currentCFrame = camera.CFrame
        local targetCFrame = CFrame.lookAt(currentCFrame.Position, targetPos)
        
        camera.CFrame = currentCFrame:Lerp(targetCFrame, Settings.AimbotSmooth)
    end)
end

-- ESP (как в v4, зелёный/красный)
local function cleanupESP(plr)
    if drawings.boxes[plr] then drawings.boxes[plr]:Remove() drawings.boxes[plr] = nil end
    if drawings.names[plr] then drawings.names[plr]:Remove() drawings.names[plr] = nil end
end

local function toggleESP(enabled)
    Settings.ESP = enabled
    if espConnection then espConnection:Disconnect() end
    for plr,_ in pairs(drawings.boxes) do cleanupESP(plr) end
    
    if not enabled then return end
    
    espConnection = RunService.RenderStepped:Connect(function()
        -- обновляем каждые 2 кадра
        if tick() % 0.033 > 0.016 then return end
        
        for _, plr in Players:GetPlayers() do
            if plr == player or not plr.Character then cleanupESP(plr) continue end
            local root = plr.Character:FindFirstChild("HumanoidRootPart")
            local head = plr.Character:FindFirstChild("Head")
            local hum = plr.Character:FindFirstChild("Humanoid")
            if not (root and head and hum and hum.Health > 0) then cleanupESP(plr) continue end
            
            local headPos3d = head.Position + Vector3.new(0,0.5,0)
            local screenHead, onScreen = camera:WorldToViewportPoint(headPos3d)
            if not onScreen then cleanupESP(plr) continue end
            
            local dir = head.Position - camera.CFrame.Position
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {player.Character or {}, plr.Character}
            params.FilterType = Enum.RaycastFilterType.Blacklist
            local result = Workspace:Raycast(camera.CFrame.Position, dir.Unit * dir.Magnitude, params)
            local visible = not result
            
            local color = visible and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,0,0)
            
            if not drawings.boxes[plr] then drawings.boxes[plr] = Drawing.new("Quad") end
            local box = drawings.boxes[plr]
            local legPos = camera:WorldToViewportPoint(root.Position - Vector3.new(0,4,0))
            local height = math.abs(screenHead.Y - legPos.Y)
            local width = height * 0.45
            box.PointA = Vector2.new(screenHead.X - width/2, screenHead.Y)
            box.PointB = Vector2.new(screenHead.X + width/2, screenHead.Y)
            box.PointC = Vector2.new(screenHead.X + width/2, legPos.Y)
            box.PointD = Vector2.new(screenHead.X - width/2, legPos.Y)
            box.Color = color
            box.Thickness = 2
            box.Transparency = 1
            box.Visible = true
            
            if not drawings.names[plr] then drawings.names[plr] = Drawing.new("Text") end
            local txt = drawings.names[plr]
            local dist = math.floor((player.Character.HumanoidRootPart.Position - root.Position).Magnitude)
            txt.Text = plr.Name .. "\n[" .. dist .. "m]"
            txt.Position = Vector2.new(screenHead.X, screenHead.Y - 25)
            txt.Color = color
            txt.Size = 15
            txt.Center = true
            txt.Outline = true
            txt.Visible = true
        end
    end)
end

-- Infinite Jump
UserInputService.JumpRequest:Connect(function()
    if Settings.InfiniteJump and player.Character then
        local hum = player.Character:FindFirstChildOfClass("Humanoid")
        if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
    end
end)

-- GUI элементы
createToggle("Fly (WASD + QE/Space)", toggleFly)
createToggle("Noclip", toggleNoclip)
createToggle("Infinite Jump", function(v) Settings.InfiniteJump = v end)
createToggle("ESP (Green=Visible)", toggleESP)
createToggle("Aimbot (RMB hold)", toggleAimbot)
createToggle("Team Check (Aimbot)", function(v) Settings.TeamCheck = v end)

createSlider("Walk Speed", 16, 500, 16, function(v)
    Settings.Speed = v
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        player.Character.Humanoid.WalkSpeed = v
    end
end)

createSlider("Fly Speed", 1, 200, 50, function(v) Settings.FlySpeed = v end)
createSlider("Aimbot FOV", 30, 360, 120, function(v) Settings.AimbotFOV = v end)
createSlider("Aimbot Smooth", 0.05, 0.5, 0.15, function(v) Settings.AimbotSmooth = v end)

-- Auto setup
player.CharacterAdded:Connect(function(char)
    local hum = char:WaitForChild("Humanoid")
    hum.WalkSpeed = Settings.Speed
end)
if player.Character then
    local hum = player.Character:FindFirstChild("Humanoid")
    if hum then hum.WalkSpeed = Settings.Speed end
end

-- Cleanup
Players.PlayerRemoving:Connect(cleanupESP)
player.CharacterRemoving:Connect(function()
    for plr,_ in pairs(drawings.boxes) do cleanupESP(plr) end
end)

print("Salt v5 загружен! Aimbot на зелёных + FOV круг + RMB hold")
