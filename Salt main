-- Salt V5 — полная переработка меню + ESP/Aimbot/FOV
-- LocalScript (StarterPlayerScripts/PlayerScripts). Тестировать в Roblox Studio (Play Solo).

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

-- Настройки (меняются UI)
local Settings = {
    Fly = false,
    FlySpeed = 60,
    Noclip = false,
    WalkSpeed = 16,
    InfiniteJump = false,
    ESP = false,
    Aimbot = false,
    AimbotFOV = 120,
    AimbotSmooth = 0.15,
    TeamCheck = true,
    AimbotHoldMode = true -- true = hold-to-aim, false = toggle
}

-- Internal
local drawings = { boxes = {}, names = {}, fov = nil }
local espConn, aimbotConn, noclipConn = nil, nil, nil
local flyBV = nil
local originalCameraType = nil

-- Bind for aimbot: saved input type + keycode (if keyboard)
local aimBind = { InputType = Enum.UserInputType.MouseButton2, KeyCode = nil } -- default: RMB
local bindingMode = false

-- GUI root in PlayerGui, high display order so it's over most things
local playerGui = player:WaitForChild("PlayerGui")
local rootGui = Instance.new("ScreenGui")
rootGui.Name = "SaltV5_UI"
rootGui.ResetOnSpawn = false
rootGui.IgnoreGuiInset = true
rootGui.DisplayOrder = 9999
rootGui.Parent = playerGui

-- MAIN FRAME (compact header + expandable scroll)
local main = Instance.new("Frame")
main.Name = "Main"
main.Size = UDim2.new(0, 320, 0, 72) -- small by default
main.Position = UDim2.new(0, 16, 0, 16)
main.BackgroundColor3 = Color3.fromRGB(22,22,22)
main.BorderSizePixel = 0
main.ZIndex = 50
main.Parent = rootGui
local mainCorner = Instance.new("UICorner", main); mainCorner.CornerRadius = UDim.new(0,10)

local header = Instance.new("Frame", main)
header.Size = UDim2.new(1,0,0,40)
header.BackgroundTransparency = 1

local title = Instance.new("TextLabel", header)
title.Size = UDim2.new(1, -80, 1, 0)
title.Position = UDim2.new(0, 12, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Salt v5"
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.TextColor3 = Color3.fromRGB(240,240,240)
title.TextXAlignment = Enum.TextXAlignment.Left
title.ZIndex = 51

local expandBtn = Instance.new("TextButton", header)
expandBtn.Size = UDim2.new(0, 44, 0, 28)
expandBtn.Position = UDim2.new(1, -56, 0, 6)
expandBtn.Text = "+"
expandBtn.Font = Enum.Font.GothamBold
expandBtn.TextSize = 20
expandBtn.BackgroundColor3 = Color3.fromRGB(40,40,40)
expandBtn.TextColor3 = Color3.fromRGB(220,220,220)
expandBtn.ZIndex = 51
Instance.new("UICorner", expandBtn).CornerRadius = UDim.new(0,6)

local dragHandle = header -- whole header draggable

-- Scroll area (hidden until expand)
local scroll = Instance.new("ScrollingFrame", main)
scroll.Name = "Scroll"
scroll.Size = UDim2.new(1, -12, 0, 360)
scroll.Position = UDim2.new(0, 6, 0, 80)
scroll.BackgroundTransparency = 1
scroll.CanvasSize = UDim2.new(0,0,0,0)
scroll.ScrollBarThickness = 8
scroll.Visible = false
scroll.ZIndex = 50

local list = Instance.new("UIListLayout", scroll)
list.Padding = UDim.new(0,8)
list.SortOrder = Enum.SortOrder.LayoutOrder

-- Minimal footer info
local info = Instance.new("TextLabel", main)
info.Size = UDim2.new(1, -12, 0, 20)
info.Position = UDim2.new(0, 8, 1, -28)
info.BackgroundTransparency = 1
info.Text = "Hold: RMB (bindable)  •  Toggle: via UI"
info.TextColor3 = Color3.fromRGB(180,180,180)
info.Font = Enum.Font.Gotham
info.TextSize = 12
info.TextXAlignment = Enum.TextXAlignment.Left
info.ZIndex = 51
info.Visible = false

-- layout helpers
local function makeRow(height)
    local f = Instance.new("Frame")
    f.Size = UDim2.new(1, 0, 0, height)
    f.BackgroundTransparency = 1
    f.Parent = scroll
    f.ZIndex = 50
    return f
end

local function makeToggle(text, initial, callback)
    local f = makeRow(36)
    local lbl = Instance.new("TextLabel", f)
    lbl.Size = UDim2.new(0.6, 0, 1, 0)
    lbl.BackgroundTransparency = 1
    lbl.Text = text
    lbl.TextColor3 = Color3.fromRGB(230,230,230)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 14
    lbl.TextXAlignment = Enum.TextXAlignment.Left

    local btn = Instance.new("TextButton", f)
    btn.Size = UDim2.new(0, 74, 0, 26)
    btn.Position = UDim2.new(1, -84, 0, 5)
    btn.BackgroundColor3 = initial and Color3.fromRGB(0,170,100) or Color3.fromRGB(55,55,55)
    btn.Text = initial and "ON" or "OFF"
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 14
    btn.TextColor3 = Color3.fromRGB(240,240,240)
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)

    local state = initial
    btn.MouseButton1Click:Connect(function()
        state = not state
        btn.Text = state and "ON" or "OFF"
        btn.BackgroundColor3 = state and Color3.fromRGB(0,170,100) or Color3.fromRGB(55,55,55)
        pcall(callback, state)
    end)
    return { frame = f, label = lbl, button = btn, set = function(v) state = v; btn.Text = v and "ON" or "OFF"; btn.BackgroundColor3 = v and Color3.fromRGB(0,170,100) or Color3.fromRGB(55,55,55) end }
end

local function makeSlider(text, min, max, default, onChange)
    local f = makeRow(56)
    local lbl = Instance.new("TextLabel", f)
    lbl.Size = UDim2.new(1, 0, 0, 20)
    lbl.BackgroundTransparency = 1
    lbl.Text = string.format("%s: %d", text, default)
    lbl.Font = Enum.Font.Gotham
    lbl.TextColor3 = Color3.fromRGB(230,230,230)
    lbl.TextSize = 13
    lbl.TextXAlignment = Enum.TextXAlignment.Left

    local barBg = Instance.new("Frame", f)
    barBg.Size = UDim2.new(1, 0, 0, 8)
    barBg.Position = UDim2.new(0, 0, 1, -14)
    barBg.BackgroundColor3 = Color3.fromRGB(45,45,45)
    barBg.BorderSizePixel = 0
    Instance.new("UICorner", barBg).CornerRadius = UDim.new(1,4)

    local rel = (default - min) / (max - min)
    local fill = Instance.new("Frame", barBg)
    fill.Size = UDim2.new(rel, 0, 1, 0)
    fill.BackgroundColor3 = Color3.fromRGB(100,190,255)
    Instance.new("UICorner", fill).CornerRadius = UDim.new(1,4)

    local knob = Instance.new("TextButton", barBg)
    knob.Size = UDim2.new(0, 16, 0, 16)
    knob.Position = UDim2.new(rel, -8, 0.5, -8)
    knob.Text = ""
    knob.BackgroundColor3 = Color3.fromRGB(250,250,250)
    Instance.new("UICorner", knob).CornerRadius = UDim.new(1,8)

    local dragging = false
    knob.InputBegan:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then dragging = true end
    end)
    UserInputService.InputEnded:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
    end)
    RunService.RenderStepped:Connect(function()
        if dragging and barBg.AbsoluteSize.X > 0 then
            local mx = UserInputService:GetMouseLocation().X
            local relX = math.clamp((mx - barBg.AbsolutePosition.X) / barBg.AbsoluteSize.X, 0, 1)
            fill.Size = UDim2.new(relX, 0, 1, 0)
            knob.Position = UDim2.new(relX, -8, 0.5, -8)
            local val = math.floor(min + (max - min) * relX)
            lbl.Text = string.format("%s: %d", text, val)
            pcall(onChange, val)
        end
    end)
    return { frame = f, label = lbl }
end

-- Expand/collapse
local expanded = false
local function setExpanded(v)
    expanded = v
    if expanded then
        main.Size = UDim2.new(0, 320, 0, 460)
        scroll.Visible = true
        info.Visible = true
        -- update canvas size after elements
        scroll.CanvasSize = UDim2.new(0, 0, 0, list.AbsoluteContentSize.Y + 12)
        expandBtn.Text = "−"
    else
        main.Size = UDim2.new(0, 320, 0, 72)
        scroll.Visible = false
        info.Visible = false
        expandBtn.Text = "+"
    end
end
expandBtn.MouseButton1Click:Connect(function() setExpanded(not expanded) end)

-- Draggable header (clamped to viewport)
local dragging = false
local dragStart = Vector2.new()
local frameStart = Vector2.new()
header.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        frameStart = Vector2.new(main.AbsolutePosition.X, main.AbsolutePosition.Y)
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then dragging = false end
        end)
    end
end)
header.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - dragStart
        local newPos = frameStart + delta
        local vp = camera and camera.ViewportSize or Vector2.new(1920,1080)
        local clampedX = math.clamp(newPos.X, 0, math.max(0, vp.X - main.AbsoluteSize.X))
        local clampedY = math.clamp(newPos.Y, 0, math.max(0, vp.Y - main.AbsoluteSize.Y))
        main.Position = UDim2.new(0, clampedX, 0, clampedY)
    end
end)

-- Particles (smoother, fewer)
local particles = {}
local pdata = {}
for i = 1, 36 do
    local p = Instance.new("Frame")
    p.Size = UDim2.new(0, 6, 0, 6)
    p.Position = UDim2.new(math.random(), 0, math.random(), 0)
    p.BackgroundColor3 = Color3.fromRGB(140, 190, 255)
    p.BackgroundTransparency = 0.5
    p.BorderSizePixel = 0
    p.ZIndex = 49
    p.Parent = main
    Instance.new("UICorner", p).CornerRadius = UDim.new(1, 0)
    particles[#particles+1] = p
    pdata[p] = { phase = math.random()*6, speed = 0.6 + math.random()*0.8, ox = math.random(), oy = math.random() }
end
RunService.RenderStepped:Connect(function(dt)
    for _, p in ipairs(particles) do
        local d = pdata[p]
        d.phase = d.phase + dt * d.speed
        local x = 0.08 + math.sin(d.phase + d.ox) * 0.36
        local y = 0.12 + math.cos(d.phase * 1.1 + d.oy) * 0.36
        p.Position = UDim2.new(x, 0, y, 0)
        p.BackgroundTransparency = 0.35 + 0.12 * math.sin(d.phase*2)
    end
end)

-- Drawing helpers (safe)
local function safeNewDrawing(kind)
    local ok, obj = pcall(function() return Drawing.new(kind) end)
    if ok then return obj end
    return nil
end
local function createQuad()
    local q = safeNewDrawing("Quad")
    if q then q.Thickness = 2; q.Transparency = 1; q.Visible = false end
    return q
end
local function createText()
    local t = safeNewDrawing("Text")
    if t then t.Size = 15; t.Center = true; t.Outline = true; t.Visible = false end
    return t
end

-- WorldToScreen helper
local function worldToScreen(pos)
    if not camera then return nil, false, 0 end
    local v3, onScreen = camera:WorldToViewportPoint(pos)
    return Vector2.new(v3.X, v3.Y), onScreen, v3.Z
end

-- Visibility check
local function isVisibleToCamera(char)
    if not char or not camera then return false end
    local target = char:FindFirstChild("Head") or char.PrimaryPart or char:FindFirstChild("HumanoidRootPart")
    if not target then return false end
    local origin = camera.CFrame.Position
    local dir = target.Position - origin
    if dir.Magnitude <= 0.001 then return true end
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = { player.Character }
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    local res = Workspace:Raycast(origin, dir, params)
    if not res then return true end
    if res.Instance and res.Instance:IsDescendantOf(char) then return true end
    return false
end

-- Update ESP (throttled)
local espTimer = 0
local espRate = 0.06
local function updateESP(dt)
    espTimer = espTimer + dt
    if espTimer < espRate then return end
    espTimer = 0

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr == player then
            if drawings.boxes[plr] then drawings.boxes[plr]:Remove(); drawings.boxes[plr] = nil end
            if drawings.names[plr] then drawings.names[plr]:Remove(); drawings.names[plr] = nil end
            continue
        end

        local char = plr.Character
        if not char then
            if drawings.boxes[plr] then drawings.boxes[plr]:Remove(); drawings.boxes[plr] = nil end
            if drawings.names[plr] then drawings.names[plr]:Remove(); drawings.names[plr] = nil end
            continue
        end

        local head = char:FindFirstChild("Head")
        local root = char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not (head and root and hum and hum.Health > 0) then
            if drawings.boxes[plr] then drawings.boxes[plr]:Remove(); drawings.boxes[plr] = nil end
            if drawings.names[plr] then drawings.names[plr]:Remove(); drawings.names[plr] = nil end
            continue
        end

        local screenHead, onHead, zHead = worldToScreen(head.Position + Vector3.new(0,0.5,0))
        local screenFoot, onFoot, zFoot = worldToScreen(root.Position - Vector3.new(0,3,0))
        if not onHead or not onFoot or zHead <= 0 or zFoot <= 0 then
            if drawings.boxes[plr] then drawings.boxes[plr]:Remove(); drawings.boxes[plr] = nil end
            if drawings.names[plr] then drawings.names[plr]:Remove(); drawings.names[plr] = nil end
            continue
        end

        local params = RaycastParams.new()
        params.FilterDescendantsInstances = { player.Character }
        params.FilterType = Enum.RaycastFilterType.Blacklist
        params.IgnoreWater = true
        local res = Workspace:Raycast(camera.CFrame.Position, (head.Position - camera.CFrame.Position), params)
        local visible = (not res) or (res.Instance and res.Instance:IsDescendantOf(char))

        local color = visible and Color3.fromRGB(0,255,140) or Color3.fromRGB(255,90,90)

        if not drawings.boxes[plr] then drawings.boxes[plr] = createQuad() end
        local box = drawings.boxes[plr]
        if box then
            local height = math.max(16, math.abs(screenHead.Y - screenFoot.Y))
            local width = math.max(10, height * 0.45)
            box.PointA = Vector2.new(screenHead.X - width/2, screenHead.Y)
            box.PointB = Vector2.new(screenHead.X + width/2, screenHead.Y)
            box.PointC = Vector2.new(screenHead.X + width/2, screenFoot.Y)
            box.PointD = Vector2.new(screenHead.X - width/2, screenFoot.Y)
            box.Color = color
            box.Visible = true
        end

        if not drawings.names[plr] then drawings.names[plr] = createText() end
        local txt = drawings.names[plr]
        if txt and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local dist = math.floor((player.Character.HumanoidRootPart.Position - root.Position).Magnitude)
            txt.Text = plr.Name .. " [" .. tostring(dist) .. "m]"
            txt.Position = Vector2.new(screenHead.X, screenHead.Y - 18)
            txt.Color = color
            txt.Visible = true
        end
    end
end

-- Get closest target by screen distance from center inside FOV (returns head part)
local function getClosestInFOV()
    local best, bestD = nil, math.huge
    local center = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)
    local radius = (Settings.AimbotFOV/2) * (camera.ViewportSize.Y / math.tan(math.rad(camera.FieldOfView/2)))
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr == player then continue end
        if Settings.TeamCheck and plr.Team == player.Team then continue end
        local char = plr.Character
        local head = char and char:FindFirstChild("Head")
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        local root = char and (char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart)
        if not (char and head and hum and hum.Health > 0 and root) then continue end

        local screenHead, onScreen, z = worldToScreen(head.Position + Vector3.new(0,0.5,0))
        if not onScreen or z <= 0 then continue end

        local params = RaycastParams.new()
        params.FilterDescendantsInstances = { player.Character }
        params.FilterType = Enum.RaycastFilterType.Blacklist
        params.IgnoreWater = true
        local res = Workspace:Raycast(camera.CFrame.Position, (head.Position - camera.CFrame.Position), params)
        if res and not res.Instance:IsDescendantOf(char) then continue end

        local d = (screenHead - center).Magnitude
        if d <= radius and d < bestD then
            bestD = d
            best = head
        end
    end
    return best
end

-- Input check for bound key/button
local function isAimHeld()
    if not aimBind or not aimBind.InputType then return false end
    local t = aimBind.InputType
    if t == Enum.UserInputType.MouseButton1 or t == Enum.UserInputType.MouseButton2 or t == Enum.UserInputType.MouseButton3 then
        local ok, pressed = pcall(function() return UserInputService:IsMouseButtonPressed(t) end)
        return ok and pressed
    elseif t == Enum.UserInputType.Keyboard then
        if aimBind.KeyCode and aimBind.KeyCode ~= Enum.KeyCode.Unknown then
            return UserInputService:IsKeyDown(aimBind.KeyCode)
        end
    end
    return false
end

-- Aimbot start/stop (manages camera type)
local function startAimbot()
    if aimbotConn then aimbotConn:Disconnect(); aimbotConn = nil end
    originalCameraType = camera and camera.CameraType or nil
    if camera then pcall(function() camera.CameraType = Enum.CameraType.Scriptable end) end

    -- create fov drawing
    if not drawings.fov then
        local ok, c = pcall(function() return Drawing.new("Circle") end)
        if ok and c then
            drawings.fov = c
            c.Thickness = 2
            c.Color = Color3.fromRGB(255,140,110)
            c.NumSides = 64
            c.Visible = true
        else
            drawings.fov = nil
        end
    end

    aimbotConn = RunService.RenderStepped:Connect(function(dt)
        if drawings.fov then
            local radius = (Settings.AimbotFOV/2) * (camera.ViewportSize.Y / math.tan(math.rad(camera.FieldOfView/2)))
            drawings.fov.Radius = radius
            drawings.fov.Position = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)
            drawings.fov.Visible = Settings.Aimbot
        end

        if not Settings.Aimbot then return end
        if Settings.AimbotHoldMode and not isAimHeld() then return end

        local targetHead = getClosestInFOV()
        if not targetHead then return end

        local targetPosition = targetHead.Position + Vector3.new(0, 0.15, 0)
        local camPos = camera.CFrame.Position
        local goal = CFrame.new(camPos, targetPosition)
        local smooth = math.clamp(Settings.AimbotSmooth or 0.15, 0, 1)
        local alpha = 1 - math.exp(-smooth * 60 * dt)
        camera.CFrame = camera.CFrame:Lerp(goal, alpha)
    end)
end

local function stopAimbot()
    if aimbotConn then aimbotConn:Disconnect(); aimbotConn = nil end
    if drawings.fov then pcall(function() drawings.fov:Remove() end); drawings.fov = nil end
    if camera and originalCameraType then pcall(function() camera.CameraType = originalCameraType end) end
    originalCameraType = nil
end

-- Toggle wrappers
local function setESP(v)
    Settings.ESP = v
    if not v then
        for k,_ in pairs(drawings.boxes) do if drawings.boxes[k] then drawings.boxes[k]:Remove(); drawings.boxes[k]=nil end end
        for k,_ in pairs(drawings.names) do if drawings.names[k] then drawings.names[k]:Remove(); drawings.names[k]=nil end end
    end
end
local function setAimbot(v)
    Settings.Aimbot = v
    if v then startAimbot() else stopAimbot() end
end
local function setNoclip(v)
    Settings.Noclip = v
    if noclipConn then noclipConn:Disconnect(); noclipConn = nil end
    if v then
        noclipConn = RunService.Stepped:Connect(function()
            if player.Character then
                for _, part in ipairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        if part.CanCollide then pcall(function() part.CanCollide = false end) end
                    end
                end
            end
        end)
    end
end
local function setFly(v)
    Settings.Fly = v
    if flyBV then flyBV:Destroy(); flyBV = nil end
    if v then
        local root = player.Character and (player.Character:FindFirstChild("HumanoidRootPart") or player.Character.PrimaryPart)
        if root then
            flyBV = Instance.new("BodyVelocity")
            flyBV.MaxForce = Vector3.new(1e5,1e5,1e5)
            flyBV.Velocity = Vector3.new(0,0,0)
            flyBV.Parent = root
        end
    end
end

-- UI creation: add rows
local tESP = makeToggle("ESP (visible=green)", Settings.ESP, function(v) setESP(v) end)
local tAIM = makeToggle("Aimbot (hold/toggle)", Settings.Aimbot, function(v) setAimbot(v) end)
local tTEAM = makeToggle("Team check", Settings.TeamCheck, function(v) Settings.TeamCheck = v end)
local tHOLD = makeToggle("Hold mode (if ON, hold bind)", Settings.AimbotHoldMode, function(v) Settings.AimbotHoldMode = v end)
local tFLY = makeToggle("Fly (WASD + Space/Q)", Settings.Fly, function(v) setFly(v) end)
local tNOCLIP = makeToggle("Noclip", Settings.Noclip, function(v) setNoclip(v) end)
local tINFJ = makeToggle("Infinite Jump", Settings.InfiniteJump, function(v) Settings.InfiniteJump = v end)

-- Bind row
do
    local f = makeRow(36)
    local lbl = Instance.new("TextLabel", f)
    lbl.Size = UDim2.new(0.4,0,1,0)
    lbl.BackgroundTransparency = 1
    lbl.Text = "Aimbot bind:"
    lbl.TextColor3 = Color3.fromRGB(230,230,230)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 14
    lbl.TextXAlignment = Enum.TextXAlignment.Left

    local btn = Instance.new("TextButton", f)
    btn.Size = UDim2.new(0,160,0,26)
    btn.Position = UDim2.new(1, -170, 0, 5)
    btn.BackgroundColor3 = Color3.fromRGB(55,55,55)
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 14
    btn.TextColor3 = Color3.fromRGB(240,240,240)
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)

    local function bindText()
        if not aimBind or not aimBind.InputType then btn.Text = "None"; return end
        if aimBind.InputType == Enum.UserInputType.Keyboard and aimBind.KeyCode then
            btn.Text = tostring(aimBind.KeyCode):gsub("Enum.KeyCode.","")
        else
            btn.Text = tostring(aimBind.InputType):gsub("Enum.UserInputType.","")
        end
    end
    bindText()

    btn.MouseButton1Click:Connect(function()
        bindingMode = true
        btn.Text = "Press any key/button..."
        btn.BackgroundColor3 = Color3.fromRGB(100,100,100)
    end)

    -- update canvas size hook
    list:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        scroll.CanvasSize = UDim2.new(0,0,0, list.AbsoluteContentSize.Y + 12)
    end)
end

-- Sliders
makeSlider("Walk Speed", 8, 500, Settings.WalkSpeed, function(v)
    Settings.WalkSpeed = v
    local h = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
    if h then pcall(function() h.WalkSpeed = v end) end
end)
makeSlider("Fly Speed", 1, 200, Settings.FlySpeed, function(v) Settings.FlySpeed = v end)
makeSlider("Aimbot FOV", 20, 360, Settings.AimbotFOV, function(v) Settings.AimbotFOV = v end)
makeSlider("Aimbot Smooth (smaller=faster)", 5, 80, math.floor((Settings.AimbotSmooth or 0.15)*100), function(v) Settings.AimbotSmooth = v/100 end)

-- Capture bind
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if bindingMode then
        aimBind.InputType = input.UserInputType
        aimBind.KeyCode = input.KeyCode ~= Enum.KeyCode.Unknown and input.KeyCode or nil
        bindingMode = false
        -- update bind button text
        for _, child in ipairs(scroll:GetChildren()) do
            if child:IsA("Frame") then
                local tb = child:FindFirstChildOfClass("TextButton")
                local tl = child:FindFirstChildOfClass("TextLabel")
                if tb and tl and tl.Text:find("Aimbot bind") then
                    if aimBind.InputType == Enum.UserInputType.Keyboard and aimBind.KeyCode then
                        tb.Text = tostring(aimBind.KeyCode):gsub("Enum.KeyCode.","")
                    else
                        tb.Text = tostring(aimBind.InputType):gsub("Enum.UserInputType.","")
                    end
                    tb.BackgroundColor3 = Color3.fromRGB(55,55,55)
                    break
                end
            end
        end
    end
end)

-- Infinite jump
UserInputService.JumpRequest:Connect(function()
    if Settings.InfiniteJump and player.Character then
        local hum = player.Character:FindFirstChildOfClass("Humanoid")
        if hum then pcall(function() hum:ChangeState(Enum.HumanoidStateType.Jumping) end) end
    end
end)

-- Main loop: ESP + Fly physics + throttling
RunService.RenderStepped:Connect(function(dt)
    if Settings.ESP then updateESP(dt) end

    -- Fly
    if Settings.Fly and flyBV then
        local root = player.Character and (player.Character:FindFirstChild("HumanoidRootPart") or player.Character.PrimaryPart)
        if root then
            local move = Vector3.new()
            local cf = camera.CFrame
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then move += cf.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then move -= cf.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then move -= cf.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then move += cf.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then move += Vector3.new(0,1,0) end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then move -= Vector3.new(0,1,0) end
            if move.Magnitude > 0 then move = move.Unit else move = Vector3.new(0,0,0) end
            flyBV.Velocity = move * (Settings.FlySpeed or 60)
        end
    end
end)

-- Ensure aimbot state on toggle changes
-- (If user toggles Aimbot via UI, start/stop handled above in setAimbot)
-- Clean up drawings on player removal / character removal
Players.PlayerRemoving:Connect(function(pl)
    if drawings.boxes[pl] then drawings.boxes[pl]:Remove(); drawings.boxes[pl] = nil end
    if drawings.names[pl] then drawings.names[pl]:Remove(); drawings.names[pl] = nil end
end)
player.CharacterRemoving:Connect(function()
    for k,_ in pairs(drawings.boxes) do if drawings.boxes[k] then drawings.boxes[k]:Remove(); drawings.boxes[k] = nil end end
    for k,_ in pairs(drawings.names) do if drawings.names[k] then drawings.names[k]:Remove(); drawings.names[k] = nil end end
    if flyBV then flyBV:Destroy(); flyBV = nil end
end)

-- init
setExpanded(false)
print("Salt v5 — переработанный интерфейс загружен. По умолчанию Aimbot bind = MouseButton2 (держать).")
