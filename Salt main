-- Salt V5 — исправленная версия меню + базовые реализации функций
-- Основа: исправлены баги UI и привязки настроек, добавлены простые реализации Fly, Noclip, WalkSpeed, InfiniteJump, ClickTeleport, ESP.
-- Доработка: скролл меню (листать вниз), точки внутри рамок, фикс ESP (ники/квадратики для каждого, цвет по LOS: зелёный=видим, красный=за стеной).
-- + Aimbot из V5 (auto на зелёных, smooth, FOV, teamcheck)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local mouse = LocalPlayer:GetMouse()
local camera = Workspace.CurrentCamera
-- Настройки
local Settings = {
Fly = false,
FlySpeed = 100,
Noclip = false,
WalkSpeed = 16,
InfiniteJump = false,
ESP = false,
ClickTeleport = false,
Aimbot = false,
AimbotFOV = 120,
AimbotSmooth = 0.15,
TeamCheck = true
}
-- Внутренние переменные / подключения
local connections = {}
local espObjects = {}
local noclipConnection
local drawings = {boxes = {}, names = {}, fovCircle = nil}
local aimTarget = nil
local aimbotConnection = nil
-- Удобные функции управления подключениями
local function addConnection(event, fn)
local c = event:Connect(fn)
table.insert(connections, c)
return c
end
local function cleanupConnections()
for _, c in ipairs(connections) do
if c.Connected then
c:Disconnect()
end
end
connections = {}
end
-- GUI: удалим старый, если есть, и создадим новый в PlayerGui
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local existing = playerGui:FindFirstChild("SaltGUI")
if existing then existing:Destroy() end
local sg = Instance.new("ScreenGui")
sg.Name = "SaltGUI"
sg.ResetOnSpawn = false
sg.Parent = playerGui
sg.ZIndexBehavior = Enum.ZIndexBehavior.Global
sg.DisplayOrder = 100
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 240, 0, 360)
mainFrame.Position = UDim2.new(0, 15, 0, 15)
mainFrame.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
mainFrame.BorderSizePixel = 0
mainFrame.ClipsDescendants = true
mainFrame.Parent = sg
Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8)
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 40)
title.BackgroundTransparency = 1
title.Text = "Salt V5 (fixed menu)"
title.TextColor3 = Color3.fromRGB(220, 220, 220)
title.TextSize = 26
title.Font = Enum.Font.GothamBold
title.TextXAlignment = Enum.TextXAlignment.Center
title.Parent = mainFrame
-- Dragging
do
local dragging, dragStart, startPos = false
title.InputBegan:Connect(function(input)
if input.UserInputType == Enum.UserInputType.MouseButton1 then
dragging = true
dragStart = input.Position
startPos = mainFrame.Position
end
end)
title.InputChanged:Connect(function(input)
if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
local delta = input.Position - dragStart
mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end
end)
UserInputService.InputEnded:Connect(function(input)
if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
end)
end
-- ScrollingFrame + автоматический лэйаут
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Size = UDim2.new(1, -10, 1, -50)
scrollFrame.Position = UDim2.new(0, 5, 0, 45)
scrollFrame.BackgroundTransparency = 1
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 5
scrollFrame.Parent = mainFrame
scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 600)  -- пространство для скролла
local uiPadding = Instance.new("UIPadding", scrollFrame)
uiPadding.PaddingLeft = UDim.new(0, 6)
uiPadding.PaddingTop = UDim.new(0, 6)
uiPadding.PaddingRight = UDim.new(0, 6)
local layout = Instance.new("UIListLayout", scrollFrame)
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Padding = UDim.new(0, 6)
-- Обновляем CanvasSize динамически
layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
scrollFrame.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 12)
end)
-- Обновляем CanvasSize динамически
layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
scrollFrame.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 12)
end)
-- Вспомогательные UI-генераторы
local function createToggle(name, initial, callback, hotkey)
local frame = Instance.new("Frame", scrollFrame)
frame.Size = UDim2.new(1, 0, 0, 32)
frame.BackgroundTransparency = 1
local label = Instance.new("TextLabel", frame)
label.Size = UDim2.new(0.75, 0, 1, 0)
label.BackgroundTransparency = 1
label.Text = name
label.TextColor3 = Color3.fromRGB(220, 220, 220)
label.TextSize = 16
label.Font = Enum.Font.GothamSemibold
label.TextXAlignment = Enum.TextXAlignment.Left
local btn = Instance.new("TextButton", frame)
btn.Size = UDim2.new(0, 50, 0, 24)
btn.Position = UDim2.new(1, -55, 0, 4)
btn.BackgroundColor3 = initial and Color3.fromRGB(0,200,120) or Color3.fromRGB(50,50,50)
btn.Text = initial and "ON" or "OFF"
btn.TextColor3 = initial and Color3.fromRGB(255,255,255) or Color3.fromRGB(180,180,180)
btn.Font = Enum.Font.GothamBold
btn.TextSize = 14
Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)
local enabled = initial
local function set(v)
enabled = v
btn.Text = enabled and "ON" or "OFF"
btn.BackgroundColor3 = enabled and Color3.fromRGB(0,200,120) or Color3.fromRGB(50,50,50)
btn.TextColor3 = enabled and Color3.fromRGB(255,255,255) or Color3.fromRGB(180,180,180)
pcall(callback, enabled)
end
btn.MouseButton1Click:Connect(function() set(not enabled) end)
-- optional hotkey
if hotkey then
addConnection(UserInputService.InputBegan, function(input, gp)
if gp then return end
if input.KeyCode == hotkey then
set(not enabled)
end
end)
end
return {
frame = frame,
set = set,
get = function() return enabled end
end
end
local function isInteger(n)
return math.floor(n) == n
end
local function round(n, decimals)
local mult = 10^(decimals or 0)
return math.floor(n * mult + 0.5) / mult
end
local function createSlider(name, min, max, default, callback)
local frame = Instance.new("Frame", scrollFrame)
frame.Size = UDim2.new(1, 0, 0, 56)
frame.BackgroundTransparency = 1
local label = Instance.new("TextLabel", frame)
label.Size = UDim2.new(1, 0, 0, 24)
label.BackgroundTransparency = 1
label.Text = name .. ": " .. tostring(default)
label.TextColor3 = Color3.fromRGB(220,220,220)
label.TextSize = 15
label.Font = Enum.Font.Gotham
local barBg = Instance.new("Frame", frame)
barBg.Size = UDim2.new(1, 0, 0, 8)
barBg.Position = UDim2.new(0, 0, 1, -14)
barBg.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Instance.new("UICorner", barBg).CornerRadius = UDim.new(1,0)
local fraction = (default - min) / math.max(1e-6, (max - min))
local barFill = Instance.new("Frame", barBg)
barFill.Size = UDim2.new(fraction, 0, 1, 0)
barFill.BackgroundColor3 = Color3.fromRGB(100, 180, 255)
Instance.new("UICorner", barFill).CornerRadius = UDim.new(1,0)
local knob = Instance.new("Frame", barBg)
knob.Size = UDim2.new(0, 16, 0, 16)
knob.Position = UDim2.new(fraction, -8, 0.5, -8)
knob.BackgroundColor3 = Color3.fromRGB(180,220,255)
Instance.new("UICorner", knob).CornerRadius = UDim.new(1,0)
local dragging = false
knob.InputBegan:Connect(function(input)
if input.UserInputType == Enum.UserInputType.MouseButton1 then
dragging = true
end
end)
UserInputService.InputEnded:Connect(function(input)
if input.UserInputType == Enum.UserInputType.MouseButton1 then
dragging = false
end
end)
-- Обновление положения при движении мыши
local rsConn = RunService.RenderStepped:Connect(function()
if dragging and barBg.AbsoluteSize.X > 0 then
local mousePos = UserInputService:GetMouseLocation()
local relX = math.clamp((mousePos.X - barBg.AbsolutePosition.X) / barBg.AbsoluteSize.X, 0, 1)
knob.Position = UDim2.new(relX, -8, 0.5, -8)
barFill.Size = UDim2.new(relX, 0, 1, 0)
local raw = min + (max - min) * relX
local value
if not isInteger(min) or not isInteger(max) or not isInteger(default) then
value = round(raw, 3) -- 3 decimals for precision; change as needed
else
value = math.floor(raw + 0.5)
end
label.Text = name .. ": " .. tostring(value)
pcall(callback, value)
end
end)
table.insert(connections, rsConn)
return {
frame = frame
end
end
-- UI: создаём элементы и связываем с Settings
local toggles = {}
toggles.fly = createToggle("Fly (F)", Settings.Fly, function(v) Settings.Fly = v end, Enum.KeyCode.F)
toggles.noclip = createToggle("Noclip (V)", Settings.Noclip, function(v) Settings.Noclip = v end, Enum.KeyCode.V)
createSlider("Walk Speed", 16, 200, Settings.WalkSpeed, function(v) Settings.WalkSpeed = v
local char = LocalPlayer.Character
if char and char:FindFirstChild("Humanoid") then
char.Humanoid.WalkSpeed = v
end
end)
toggles.infjump = createToggle("Infinite Jump", Settings.InfiniteJump, function(v) Settings.InfiniteJump = v end)
toggles.esp = createToggle("ESP", Settings.ESP, function(v) Settings.ESP = v end)
toggles.clicktp = createToggle("Click TP", Settings.ClickTeleport, function(v) Settings.ClickTeleport = v end)
toggles.aim = createToggle("Aimbot", Settings.Aimbot, function(v) Settings.Aimbot = v end)
createSlider("Aimbot FOV", 50, 500, Settings.AimbotFOV, function(v) Settings.AimbotFOV = v end)
createSlider("Aimbot Smooth", 0.05, 0.5, Settings.AimbotSmooth, function(v) Settings.AimbotSmooth = v end)
toggles.team = createToggle("Team Check", Settings.TeamCheck, function(v) Settings.TeamCheck = v end)
-- Реализация простых функций фич
-- 1) WalkSpeed: применяем при появлении персонажа
LocalPlayer.CharacterAdded:Connect(function(char)
spawn(function()
local hum = char:WaitForChild("Humanoid")
hum.WalkSpeed = Settings.WalkSpeed or 16
end)
end)
-- 2) Infinite Jump: реагируем на JumpRequest (Roblox API)
addConnection(UserInputService.JumpRequest, function()
if Settings.InfiniteJump then
local char = LocalPlayer.Character
if char and char:FindFirstChild("Humanoid") then
char.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
end
end
end)
-- 3) Click Teleport
addConnection(mouse.Button1Down, function()
if Settings.ClickTeleport then
local target = mouse.Hit and mouse.Hit.p
local char = LocalPlayer.Character
if char and char:FindFirstChild("HumanoidRootPart") then
char.HumanoidRootPart.CFrame = CFrame.new(target + Vector3.new(0, 3, 0))
end
end
end)
-- 4) Noclip: включаем/отключаем прослушивая RunService.Stepped
do
local function setNoclip(enabled)
if noclipConnection and noclipConnection.Connected then
noclipConnection:Disconnect()
noclipConnection = nil
end
if enabled then
noclipConnection = RunService.Stepped:Connect(function()
local char = LocalPlayer.Character
if not char then return end
for _, part in ipairs(char:GetDescendants()) do
if part:IsA("BasePart") then
part.CanCollide = false
end
end
end)
end
end
-- слежение за Settings.Noclip
addConnection(RunService.Heartbeat, function()
-- на каждый heartbeat проверяем и применяем, дешево и просто
if noclipConnection == nil and Settings.Noclip then
setNoclip(true)
elseif noclipConnection ~= nil and not Settings.Noclip then
setNoclip(false)
end
end)
end
-- 5) Простая ESP — BillboardGui над игроками
local function clearESP()
for k, v in pairs(espObjects) do
if v and v:FindFirstChild("ESP") then v.ESP:Destroy() end
espObjects[k] = nil
end
end
local function updateESP()
clearESP()
if not Settings.ESP then return end
for _, pl in ipairs(Players:GetPlayers()) do
if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
local root = pl.Character.HumanoidRootPart
local bg = Instance.new("BillboardGui", root)
bg.Name = "ESP"
bg.Size = UDim2.new(0, 100, 0, 30)
bg.StudsOffset = Vector3.new(0, 3, 0)
bg.AlwaysOnTop = true
local label = Instance.new("TextLabel", bg)
label.Size = UDim2.new(1,0,1,0)
label.BackgroundTransparency = 1
label.Text = pl.Name
label.TextColor3 = Color3.fromRGB(255, 200, 50)
label.TextStrokeTransparency = 0.5
label.Font = Enum.Font.SourceSansBold
label.TextScaled = true
espObjects[pl] = root
end
end
end
-- отслеживаем изменения игроков и настроек
Players.PlayerAdded:Connect(function() updateESP() end)
Players.PlayerRemoving:Connect(function() updateESP() end)
addConnection(RunService.Heartbeat, function()
-- обновляем ESP раз в секунда для простоты
if Settings.ESP then
if not espObjects._lastTick or tick() - espObjects._lastTick > 1 then
espObjects._lastTick = tick()
updateESP()
end
else
clearESP()
end
end)
-- 6) Aimbot на зелёных (auto)
local function getClosestGreen()
local closest = nil
local minDist = math.huge
local mousePos = Vector2.new(mouse.X, mouse.Y)
for _, plr in Players:GetPlayers() do
if plr == LocalPlayer or not plr.Character then continue end
local root = plr.Character:FindFirstChild("HumanoidRootPart")
local head = plr.Character:FindFirstChild("Head")
local hum = plr.Character:FindFirstChild("Humanoid")
if not (root and head and hum and hum.Health > 0) then continue end
if Settings.TeamCheck and plr.Team == LocalPlayer.Team then continue end
local headPos, onScreen = camera:WorldToViewportPoint(head.Position)
if not onScreen then continue end
-- LOS check
local dir = (head.Position - camera.CFrame.Position)
local params = RaycastParams.new()
params.FilterDescendantsInstances = {LocalPlayer.Character, plr.Character}
params.FilterType = Enum.RaycastFilterType.Blacklist
local result = Workspace:Raycast(camera.CFrame.Position, dir, params)
if result then continue end -- за стеной
local screenDist = (Vector2.new(headPos.X, headPos.Y) - mousePos).Magnitude
if screenDist < minDist and screenDist < (Settings.AimbotFOV / 2 * camera.ViewportSize.Y / math.tan(math.rad(camera.FieldOfView / 2))) then
minDist = screenDist
closest = head
end
end
return closest
end
local function toggleAimbot(enabled)
Settings.Aimbot = enabled
if aimbotConnection then aimbotConnection:Disconnect() end
if not enabled then
if drawings.fovCircle then drawings.fovCircle:Remove() drawings.fovCircle = nil end
return
end
-- FOV круг
drawings.fovCircle = Drawing.new("Circle")
drawings.fovCircle.Thickness = 2
drawings.fovCircle.Color = Color3.fromRGB(255, 100, 100)
drawings.fovCircle.Transparency = 0.8
drawings.fovCircle.NumSides = 100
drawings.fovCircle.Radius = Settings.AimbotFOV / 2 * (camera.ViewportSize.Y / math.tan(math.rad(camera.FieldOfView / 2)))
drawings.fovCircle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
drawings.fovCircle.Visible = true
-- Aimbot logic (auto, без RMB)
aimbotConnection = RunService.RenderStepped:Connect(function()
drawings.fovCircle.Radius = Settings.AimbotFOV / 2 * (camera.ViewportSize.Y / math.tan(math.rad(camera.FieldOfView / 2)))
aimTarget = getClosestGreen()
if not aimTarget then return end
local targetPos = aimTarget.Position + Vector3.new(0, 0.2, 0) -- чуть выше головы
local currentCFrame = camera.CFrame
local targetCFrame = CFrame.lookAt(currentCFrame.Position, targetPos)
camera.CFrame = currentCFrame:Lerp(targetCFrame, Settings.AimbotSmooth)
end)
end
-- Завершение: выводим сообщение
print("Salt V5 (fixed menu) loaded — UI fixed, keybinds & basic features wired. Expand features as needed.")
-- Auto setup
LocalPlayer.CharacterAdded:Connect(function(char)
local hum = char:WaitForChild("Humanoid")
hum.WalkSpeed = Settings.WalkSpeed
end)
if LocalPlayer.Character then
local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
if hum then hum.WalkSpeed = Settings.WalkSpeed end
end
-- Cleanup on exit
addConnection(game.Closing, cleanupConnections)
